<style scoped>
div {
	position: fixed;
	top: 0;
	bottom: 0;
	right: 0;
	left: 0;
	z-index: 100;
	background-color: rgba(255, 255, 255, 0.4);

	display: flex;
	justify-content: center;
	align-items: center;
}
</style>

<template>
	<div v-if=shown>
		<el-progress type=circle :percentage="Math.round(progress)" status=text>{{ status }}</el-progress>
		<a ref=a :href=url :type=type :download=name />
	</div>
</template>

<script>
import Vue from 'vue';
import QRCode from 'qrcode';
import JSZip from 'jszip';
import {Base64} from 'js-base64';


async function tick() {
	await new Promise((resolve, reject) => Vue.nextTick(resolve));
}


async function oneQRToDataURL(data, type, margin, background, foreground) {
	const options = {
		color: {
			light: background,
			dark: foreground,
		},
		margin: margin,
		scale: 8,
	};

	switch (type) {
	case 'png':
		return await QRCode.toDataURL(data, Object.assign(options, {type: 'image/png'}));
	case 'svg':
		return 'data:image/svg+xml;base64,' + Base64.encode(await QRCode.toString(data, Object.assign(options, {type: 'image/svg'})));
	default:
		throw new ValueError(`unknown type: ${type}`);
	}
}


async function allQRToDataURL(data, type, margin, background, foreground, callback) {
	const zip = new JSZip();

	zip.file('batch-qr', '', {dir: true});

	for (let i=0; i<data.length; i++) {
		callback(i/data.length * 50, 'generating');
		try {
			const url = await oneQRToDataURL(data[i], type, margin, background, foreground);

			zip.file(`batch-qr/${i + 1}.${type}`, url.replace(/.*?,/, ''), {base64: true, comment: data[i]});
		} catch {
		}
	}

	await tick();

	const base64 = await zip.generateAsync({type: 'base64', compression: 'DEFLATE', comment: 'Generated by MacRat/BacthQR'}, ({percent, currentFile}) => {
		callback(percent/2 + 50, 'compressing');
	})

	callback(100, 'downloading');

	return 'data:application/zip;base64,' + base64;
}


export default {
	data() {
		return {
			shown: false,
			progress: 0,
			status: '',
			url: '',
			type: 'application/zip',
			name: 'batch-qr',
		};
	},
	methods: {
		async _prepare(name, type) {
			this.status = 'generating';
			this.progress = 0;
			this.shown = true;
			this.type = type;
			this.name = name;

			await tick();
		},
		async _download() {
			this.status = 'downloading';
			this.progress = 100;

			await tick();

			this.$refs.a.click();

			this.shown = false;
		},
		async downloadIt(data, type, name, options) {
			await this._prepare(name, type === 'svg' ? 'image/svg+xml' : 'image/png');

			this.url = await oneQRToDataURL(
				data,
				type,
				options.margin,
				options.color.light,
				options.color.dark,
			);

			await this._download();
		},
		async downloadAll(data, type, options) {
			await this._prepare('batch-qr', 'application/zip');

			this.url = await allQRToDataURL(
				data,
				type,
				options.margin,
				options.color.light,
				options.color.dark,
				(progress, status) => {
					this.progress = progress;
					this.status = status;
				},
			);

			await this._download();
		},
	},
};
</script>
